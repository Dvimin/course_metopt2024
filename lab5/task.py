import numpy as np

f = lambda x: 4 * x[0] + x[1] + 4 * np.sqrt(1 + 3 * x[0] ** 2 + x[1] ** 2) + x[2] ** 2

grad_f = lambda x: [
    4 + 12 * (x[0] / np.sqrt(1 + 3 * x[0] ** 2 + x[1] ** 2)),
    1 + 4 * (x[1] / np.sqrt(1 + 3 * x[0] ** 2 + x[1] ** 2)),
    2 * x[2]
]

restrictions = [
    lambda x: 7 * (x[0] + 1) ** 2 + (x[1] + 1) ** 2 + (x[2] - np.log(2)) ** 2 - 4,
    lambda x: (x[0] - 1 / 2) ** 2 + (x[1] + 1) ** 2 + (x[2] + 1) ** 2 - 4,
    lambda x: (x[0] + 2) ** 2 / 4 + 8 * (x[1] + 0.5) ** 2 + x[2] ** 2 - 2.5,
    lambda x: x[2] - 0.5
    #lambda x: -x[2]

    # -x[2] - ограничение для точки глобального минимума на границе
    # x[2] - 0.5 - ограничение для точки глобального минимума в области

]

restrictions_grad = [
    lambda x: [14 * (x[0] + 2), 2 * (x[1] + 1), 2 * (x[2] - np.log(2))],
    lambda x: [2 * (x[0] - 0.5), 2 * (x[1] + 1), 2 * (x[2] + 1)],
    lambda x: [0.5 * (x[0] + 2), 2 * 16 * (x[1] + 0.5), 2 * x[2]],
    lambda x: [0, 0, 1]
    #lambda x: [0, 0, -1]

    #[0, 0, 1] - градиент ограничения для точки глобального минимума в области
    #[0, 0, -1] - градиент ограничения для точки глобального минимума на границе
]
